```python
import sys
import heapq
import collections

N, E = tuple(map(int,sys.stdin.readline().rstrip().split()))

graph = collections.defaultdict(list)

for _ in range(E):
    u, v, w = tuple(map(int, sys.stdin.readline().rstrip().split()))
    graph[u].append((v, w))
    graph[v].append((u, w))
    
V1, V2 = tuple(map(int, sys.stdin.readline().rstrip().split()))
inevitable = {V1, V2}

Q = [(0, 1)]
dist = collections.defaultdict(lambda: float('inf'))
dist[1] = 0

while Q:
    length, node = heapq.heappop(Q)
    
    if node in inevitable:
        inevitable.remove(node)
        if not inevitable:
            break

    if length > dist[node]:
        continue

    for child, w in graph[node]:
        alt = length + w
        if alt < dist[child]:
            dist[child] = alt
            heapq.heappush(Q, (alt, child))

if dist[V1] == float('inf') or dist[V2] == float('inf'):
    print(-1)
    sys.exit(0)

Q = [(dist[V1], V1)]
dist_v1 = collections.defaultdict(lambda: float('inf'))
dist_v1[V1] = dist[V1]

while Q:
    length, node = heapq.heappop(Q)

    if node == V2:
        break

    if length > dist_v1[node]:
        continue

    for child, w in graph[node]:
        alt = length + w
        if alt < dist_v1[child]:
            dist_v1[child] = alt
            heapq.heappush(Q, (alt, child))

if dist_v1[V2] == float('inf'):
    print(-1)
    sys.exit(0)

Q = [(dist_v1[V2], V2)]
dist_v2 = collections.defaultdict(lambda: float('inf'))
dist_v2[V2] = dist_v1[V2]

while Q:
    length, node = heapq.heappop(Q)

    if node == N:
        print(length)
        sys.exit(0)

    if length > dist_v2[node]:
        continue

    for child, w in graph[node]:
        alt = length + w
        if alt < dist_v2[child]:
            dist_v2[child] = alt
            heapq.heappush(Q, (alt, child))

print(-1)
sys.exit(0)
```
