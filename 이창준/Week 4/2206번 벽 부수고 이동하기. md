```python

import sys
from collections import deque

input = sys.stdin.read
lines = input().splitlines()
N, M = map(int, lines[0].split())
matrix = [list(map(int, lines[i])) for i in range(1, N + 1)]

# 방문 배열을 (N, M, 2) 크기로 정의 (0: 벽을 부술 기회 없음, 1: 벽을 부술 기회 있음)
visited = [[[0] * 2 for _ in range(M)] for _ in range(N)]

# BFS 함수 정의
def bfs(x, y, d, chance):
    queue = deque([(x, y, d, chance)])  # (x, y, 거리, 벽을 부술 기회)
    visited[x][y][chance] = 1  # 처음 방문 처리
    
    # 상, 하, 좌, 우 이동 방향 벡터
    direction_vector = [(1, 0), (-1, 0), (0, 1), (0, -1)]
    
    while queue:
        cx, cy, cd, cc = queue.popleft()  # 현재 좌표 cx, cy와 거리 cd, 벽을 부술 기회 cc
        
        # 목표 지점에 도달했으면 그때의 거리 반환
        if cx == N - 1 and cy == M - 1:
            return cd
        
        for vx, vy in direction_vector:
            newX = cx + vx
            newY = cy + vy
            
            # 새로운 좌표가 유효한 범위 내에 있는지 확인
            if 0 <= newX < N and 0 <= newY < M:
                # 벽이 아닌 곳이라면
                if matrix[newX][newY] == 0 and visited[newX][newY][cc] == 0:
                    visited[newX][newY][cc] = 1  # 방문 처리
                    queue.append((newX, newY, cd + 1, cc))  # 벽을 부수지 않고 이동

                # 벽인 곳이라면, 벽을 부술 기회가 남아있을 때만 이동
                elif matrix[newX][newY] == 1 and cc == 1 and visited[newX][newY][0] == 0:
                    visited[newX][newY][0] = 1  # 벽을 부수고 방문 처리
                    queue.append((newX, newY, cd + 1, 0))  # 벽을 부수고 이동
    
    return -1  # 목적지에 도달할 수 없으면 -1 반환

# BFS 실행
shortest = bfs(0, 0, 1, 1)  # (0, 0)에서 출발, 처음에는 벽을 부술 기회 1번 있음
print(shortest)
```
