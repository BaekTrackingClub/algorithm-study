# 벽 부수고 이동하기 2206

## 문제

## 입력

## 출력

## 접근방법
일단 bfs로 벽 부수지 않고 최단거리 구하는 코드를 만들어 놓고 시작했다.
여기서 계속 막혀서 서치를 해보았다..
큐에 벽을 부순여부를 추가하여 넣어주는 방법을 써야한다는걸 보고 다시 시도했다.
큐의 흐름으로 생각하니 조금 이해가 되었다. 
0 0 0 0
1 1 1 0
0 0 0 0
0 1 1 1
0 0 0 0
을 예시로 정리해 보겠다.

처음에 0,0에서 시작 이때 아직 벽을 안부셨기때문에 큐에 0,0,0을 넣어준다.
0,0,0을 큐에서 pop해주고 그 다음 갈수 있는곳은 찾아보면 아래와 오른쪽 두곳이다.
이때 아래(1,0)은 벽을 부수고 가야하기 때문에 1,0,1 을 큐에 넣어주고 
오른쪽은 길 이기 때문에 0,1,0 을 큐에 넣어준다.
현재 큐에는 [(1,0,1) (0,1,0)] 이렇게 들어있다.

1,0,1 을 pop해주고 다음 갈곳을 찾아보면 아래와 오른쪽인데 
오른쪽은 벽이다. 이미 벽을 한번 부셨으므로 아래로만 갈수있다.
따라서 큐에 2,0,1 을 추가해준다.

큐는 (0,1,0)(2,0,1) 이므로 다음으로 0,1,0을 pop해서 반복해주면 된다.



```python
from collections import deque

N, M = map(int, input().split())
maps = []
distance = [[0] * M for _ in range(N)]

for _ in range(N):
  maps.append(list(map(int, input())))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs(x, y, wall):
  queue = deque([(x, y, wall)])
  distance[x][y] = 1

  while queue:
    x1, y1, w = queue.popleft()
    #print('x1 y1', x1, y1, w)
    #print('큐',queue)
    #print()

    for i in range(4):
      nx = x1 + dx[i]
      ny = y1 + dy[i]
      #print('시작 기준', nx, ny)
      
      if nx >= 0 and nx < N and ny >= 0 and ny < M:
        
        
        if maps[nx][ny] == 1 and w == 0: #부수기 
          distance[nx][ny] = distance[x1][y1] + 1
          queue.append((nx,ny,1))
          #print('부수고 길', queue)

        
        elif maps[nx][ny] == 0 and distance[nx][ny] == 0: #길
          distance[nx][ny] = distance[x1][y1] + 1
          queue.append((nx,ny,w))
          #print('그냥 길', queue)


bfs(0, 0, 0)
#print(distance)

if distance[N - 1][M - 1] == 0:
  distance[N - 1][M - 1] = -1
print(distance[N - 1][M - 1])
```

-작성중-
+ distance 중복해결 해야함 -> distance를 3차원 리스트로해서 뿌순경우 안뿌순경우 따로 저장
